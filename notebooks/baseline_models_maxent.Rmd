---
title: 'SDM Benchmark Study Part 8: Fitting and Testing MaxEnt Models'
author: "Benton Tripp"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: show
    theme: flatly
    df_print: paged
  
---

<style>
.tocify-extend-page {
  height: 0 !important;
}
.post_navi {
  display: flex
}

.post_navi-label {
  font-size: 0.8em;
  opacity: 0.5
}

.post_navi .post_navi-item {
  padding: 0 2.2em;
  width: 50%;
  position: relative;
  color: inherit !important
}

.post_navi .nav_prev {
  text-align: left
}

.post_navi .nav_next {
  text-align: right
}

.post_navi .nav_prev .post_navi-arrow {
  left: 0
}

.post_navi .nav_next .post_navi-arrow {
  right: 0
}

.post_navi .post_navi-arrow {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  font-size: 2.5em;
  opacity: 0.3
}

footer .wrapper {
  max-width: -webkit-calc(800px - (30px*2));
  max-width: calc(800px - (30px*2));
  margin-right: auto;
  margin-left: auto;
  padding-right: 30px;
  padding-left: 30px
}

@media screen and (max-width:800px) {
  footer .wrapper {
    max-width: -webkit-calc(800px - (30px));
    max-width: calc(800px - (30px));
    padding-right: 15px;
    padding-left: 15px
  }
}

footer .wrapper:after,
.footer-col-wrapper:after {
  content: "";
  display: table;
  clear: both
}

.svg-icon {
  width: 26px;
  height: 16px;
  display: inline-block;
  fill: #828282;
  padding-right: 5px;
  vertical-align: text-top
}

.social-media-list li+li {
  padding-top: 5px
}

.site-footer {
  border-top: 1px solid #e8e8e8;
  padding: 30px 0
}

.footer-heading {
  font-size: 18px;
  margin-bottom: 15px
}

.contact-list,
.social-media-list {
  list-style: none;
  margin-left: 0;
  width: 155px;
}

.footer-col-wrapper {
  font-size: 15px;
  color: #828282;
  margin-left: -15px
}

.footer-col {
  float: left;
  margin-bottom: 15px;
  padding-left: 15px
}

.footer-col-1 {
  width: 30%;
}

.footer-col-2 {
  width: 25%;
}

.footer-col-3 {
  width: 45%;
}

@media screen and (max-width:800px) {

  .footer-col-1,
  .footer-col-2 {
    width: -webkit-calc(50% - (30px/2));
    width: calc(50% - (30px/2))
  }

  .footer-col-3 {
    width: -webkit-calc(100% - (30px/2));
    width: calc(100% - (30px/2))
  }
}

@media screen and (max-width:600px) {
  .footer-col {
    float: none;
    width: -webkit-calc(100% - (30px/2));
    width: calc(100% - (30px/2))
  }
}
</style>

```{r setup, include=F, warning=F, message=F}
knitr::opts_chunk$set(echo = T, message=F, warning=F, cache=F, root.dir="..")
```

## Overview


## Setup

```{r setup-2, results='hide'}

library(sf)
library(terra)
library(ggplot2)
library(ggpubr)
library(dplyr)
library(readr)
library(data.table)
library(knitr)
library(purrr)
library(caret)
library(predicts)

# Set seed for splitting and modeling
set.seed(19)

# Load the dataset saved in part 2 of the study 
df <- readRDS("artifacts/final_data/final_data.rds") %>% setDT()

# Define some global variables that will be referenced throughout the modeling 
states <- sort(unique(df$state))
species <- sort(unique(df$common.name))
spec.state <- expand.grid(species=species, 
                          state=states, 
                          stringsAsFactors=F)

# Rasters
rasters <- states %>% 
  set_names() %>%
  purrr::map(~{
   r <- rast(file.path("artifacts/preprocessed_rasters_updated",
                             paste0(.x, ".tif")))
   r <- names(r) %>%
      set_names() %>%
      purrr::map(~terra::project(r[[.x]], 
                                 crs(paste0("EPSG:", 4326)))) %>%
      rast()
  })

# Get model or other object from cache if it has been saved before
get.object <- function(obj, file.name, obj.path, read.func=readRDS, 
                       save.func=saveRDS, ...) {
  f.path <- file.path(obj.path, file.name)
  if (!dir.exists(obj.path)) {
    dir.create(obj.path)
  }
  # Object cache check
  if (file.exists(f.path)) {
    obj <- read.func(f.path)
  } else {
    save.func(obj, f.path, ...)
  }
  obj
}

```


## MaxEnt Models

### Load Variable Importance

```{r varimp}
# Load variable importance from fitted LASSO models
lasso.model.path="artifacts/models/lasso_3_fs"

# Define min/max scaling function for rasters
min.max.scale <- function(x, na.rm=T) {
  min.x <- min(x, na.rm=na.rm)
  max.x <- max(x, na.rm=na.rm)
  (x - min.x) / (max.x - min.x)
}

get.var.imp <- function(st, spec, dir="artifacts/models/lasso_3_fs") {
  files <- list.files(dir) %>%
    .[grepl(paste(tolower(gsub(" ", "_", spec)), st, sep="_"), .)] %>%
    file.path(dir, .)
  if (length(files) == 0) return(
    tibble(
      common.name=character(0),
      state=character(0),
      variable=character(0),
      importance=numeric(0),
      wt=numeric(0),
      weighted.imp=numeric(0)
    )
  )
  var.imp <- purrr::map_df(files, ~{
    fit <- readRDS(.x)
    coef.df <- coef(fit$finalModel, s = fit$bestTune$lambda) %>%
      as.matrix() %>%
      as.data.frame()
    # Remove the intercept
    coef.df <- coef.df[-1, , drop = F]
    # Create a data frame of variable importance
    var.importance <- tibble(
      common.name = spec,
      state = st,
      variable = rownames(coef.df),
      importance = abs(coef.df[,1])
    ) %>%
      # Rank variables by importance
      arrange(state, common.name, -importance, variable) %>%
      # Only look at variables where imp. > 0
      filter(importance > 0)
  }) %>%
    mutate(n=n()) %>%
    group_by(common.name, state, variable, n, .drop=F) %>%
    summarize(importance=median(importance), 
              wt=n()) %>%
    ungroup() %>%
    mutate(wt=wt/n) %>%
    dplyr::select(-n) %>%
    mutate(weighted.imp=min.max.scale(wt*importance)) %>%
    arrange(-weighted.imp, variable) 
}

var.imp <- purrr::map_df(1:nrow(spec.state), function(i) {
  spec <- spec.state[i,]$species
  st <- spec.state[i,]$state
  get.var.imp(st, spec)
})

var.imp

```


```{r ipp-model, results='hide'}

get.f1 <- function(locations.df, thresh=0.5, method="F1") {
  metrics <- locations.df[, .(pred=factor(ifelse(p.obs > thresh, T, F), 
                               levels=c("FALSE", "TRUE")), 
          obs=factor(obs, levels=c("FALSE", "TRUE")))] %>% 
    confusionMatrix(reference=.$pred, data=.$obs, 
                    positive = "TRUE", 
                    mode="everything") %>%
    as.list() %>%
    .[["byClass"]] %>%
    as.list()
  if (method == "F1") {
    return(metrics$F1)
  } else if (method == "SS") {
    # Penalize heavily if either is near zero or NA
    if (is.na(metrics$Sensitivity) || is.na(metrics$Specificity)) {
      return(-1e6) 
    } else if (metrics$Sensitivity < .05 || metrics$Specificity < .05) {
      return(-1e6) 
    }
    
    # Combine Specificity and Sensitivity (e.g., geometric mean)
    combined.metric = sqrt(metrics$Sensitivity * metrics$Specificity)
    return(combined.metric)
  }
}

optimize.f1 <- function(locations.df) {
  objective.fn <- function(thresh) {
    # Negative because we want to maximize
    -get.f1(locations.df=locations.df, thresh=thresh, method="SS")  
  }
  opt.result <- optimize(objective.fn, lower=0.05, upper=0.95)
  return(opt.result$minimum)  # Return the optimal threshold
}

get.acc <- function(test, thresh) {
  df <- test[, .(pred=as.factor(ifelse(p.obs > thresh, T, F)), obs=as.factor(obs))]
  cm <- confusionMatrix(df$pred, df$obs, positive = "TRUE", mode="everything")
}


purrr::walk(1:nrow(spec.state), function(i) {
  covariates.keep <- 50
  spec <- spec.state[i,]$species
  st <- spec.state[i,]$state
  # Set paths for model/results
  me.results.path <- file.path("artifacts/test_results/maxent",
                               paste0(spec, "_", st, "_maxent.rds"))
  me.path <- file.path("artifacts/models/maxent", 
                       paste0(spec, "_", st, "_maxent.rds"))
  if (!file.exists(me.results.path)) {
    cat("Starting MaxEnt for", spec, "in", st, "\n")
    # Load rasters and point data
    r <- rasters[[st]]
      
    Q <- readRDS(file.path("artifacts", "train_spatstat_Q_2",
                           paste0(st, "_", spec, "_Q.rds")))
    Q.test <- readRDS(file.path("artifacts", "test_spatstat_Q_2",
                                paste0(st, "_", spec, "_Q.rds")))
    p.train <- tibble(x=Q$data$x, y=Q$data$y) 
    # %>% sf::st_as_sf(coords = c("x", "y"), crs=4326)
    a.train <- tibble(x=Q$dummy$x, y=Q$dummy$y)
    p.test <- tibble(x=Q.test$data$x, y=Q.test$data$y) 
    a.test <- tibble(x=Q.test$dummy$x, y=Q.test$dummy$y)
      
    no.model.err <- F
    spec.sens.check <- F
    while (!no.model.err | !spec.sens.check) {
      # Select covariates based on feature importance
      cat("\tFetching variable importance with `covariates.keep` set to", 
          covariates.keep, "\n")
      fs.df <- var.imp %>% 
        filter(state == st & common.name == spec) %>%
        mutate(var1 = purrr::map_chr(variable, 
                                     ~ stringr::str_split(.x, "\\:")[[1]][1]),
               var2 = purrr::map_chr(variable, ~ {
                 split_result <- stringr::str_split(.x, "\\:")[[1]]
                 if(length(split_result) > 1) split_result[2] else NA_character_
               })) %>%
        mutate(variable = ifelse(is.na(var2), 
                                 var1, 
                                 paste(var1, var2, sep = ":"))) %>%
        # Keep only pre-determined # of variables/interactions
        head(covariates.keep)
      
      if (nrow(fs.df) > 0) {
        covariates <- c(fs.df$var1, fs.df$var2) %>% 
          unique() %>% 
          sort()
        
        # Load/compute filtered & pre-processed rasters
        covariates <- r[[covariates]]
        
        if (length(names(covariates)) < covariates.keep) {
          covariates.keep <- length(names(covariates)) 
        } else if (length(names(covariates)) > covariates.keep) {
          covariates <- covariates[[1:covariates.keep]]
        }
        
      } else {
        stop("\tThere are no specified covariates for", spec, st, "\n")
      }
      
      # Fit the MaxEnt Model
      cat("\tFitting MaxEnt Model...\n")
      fit.me <- tryCatch({
        predicts::MaxEnt(x=covariates, p=p.train) %>%
          get.object(
            obj=.,
            file.name=paste0(spec, "_", st, "_maxent.rds"), 
            obj.path="artifacts/models/maxent")}, 
        error=function(e) NULL)
      no.model.err <- !is.null(fit.me)
      if (!no.model.err) {
        file.remove(me.path)
        covariates.keep <- covariates.keep - 1
        if (covariates.keep < 1) {
          stop("\tUnable to successfully fit a model given the data.\n")
        } 
        next
      } 
      locations.train <- data.table::rbindlist(
        list(
          data.table(x=Q$data$x, y=Q$data$y, obs=T), 
          data.table(x=Q$dummy$x, y=Q$dummy$y, obs=F)
        )
      ) 
      purrr::walk(names(covariates), function(n) {
        locations.train[, (n) := 
                          terra::extract(covariates[[n]], 
                                         cbind(locations.train$x, 
                                               locations.train$y))]
      })
      me.pred <- predict(fit.me, locations.train)
      me.train <- cbind(locations.train, data.table(p.obs = me.pred))
      optimal.threshold <- optimize.f1(me.train)
      cm <- get.acc(me.train, optimal.threshold)
      acc <- tibble(
        common.name=spec,
        state=st,
        covariate.count=covariates.keep,
        optimal.threshold=optimal.threshold 
      ) %>%
        cbind(as.list(c(cm$overall, cm$byClass)) %>% 
                as_tibble()) %>%
        select(common.name:Accuracy, Sensitivity, Specificity, F1)
      cat("Train Results:\n Species:", spec, "\n",
          "State:", st, "\n",
          "Covariates:", covariates.keep, "\n",
          "Optimal Threshold:", optimal.threshold, "\n",
          "Accuracy:", acc$Accuracy, "\n",
          "F1:", acc$F1, "\n",
          "Sensitivity (TP Rate):", acc$Sensitivity, "\n",
          "Specificity (TN Rate):", acc$Specificity, "\n")
      if ((acc$Sensitivity == 1 & acc$Specificity == 0) | 
          (acc$Sensitivity == 0 & acc$Specificity == 1)) {
        cat("\tThe sensitivity/specificity is a 0/1 pair",
            "for covariates.keep ==", covariates.keep, "\n")
        spec.sens.check <- F
        file.remove(glm.path)
        covariates.keep <- covariates.keep - 1
        if (covariates.keep < 1) {
          stop("\tUnable to successfully fit a model given the data.\n")
        } 
        next
      } else {
        spec.sens.check <- T
      }
    }
    
    me.results <- get.object(
      obj={
        locations.test <- data.table::rbindlist(
          list(
            data.table(x=Q.test$data$x, y=Q.test$data$y, obs=T), 
            data.table(x=Q.test$dummy$x, y=Q.test$dummy$y, obs=F)
          )
        ) 
        purrr::walk(names(covariates), function(n) {
          locations.test[, (n) := 
                           terra::extract(covariates[[n]], 
                                          cbind(locations.test$x,
                                                locations.test$y))]
        })
        me.pred <- predict(fit.me, locations.test)
        me.test <- cbind(locations.test, data.table(p.obs=me.pred))
        cm <- get.acc(me.test, optimal.threshold)
        test.acc <- tibble(
          common.name=spec,
          state=st,
          covariate.count=covariates.keep,
          optimal.threshold=optimal.threshold 
        ) %>%
          cbind(as.list(c(cm$overall, cm$byClass)) %>% 
                  as_tibble()) %>%
          select(common.name:Accuracy, Sensitivity, Specificity, F1)
        all.predictions <- predict(fit.me, covariates)
        list(
          test=me.test,
          train=me.train,
          all.preds=all.predictions,
          thresh=optimal.threshold,
          train.accuracy=acc,
          test.accuracy=test.acc
        )
      },
      file.name=paste0(spec, "_", st, "_maxent.rds"),
      obj.path="artifacts/test_results/maxent"
    )
    cat("\tFinished MaxEnt model for", spec, "in", st, "\n")
  }
  gc()
})
```



## Results

```{r examine-mel-results}

me.models <- purrr::map_df(1:nrow(spec.state), function(i) {
  spec <- spec.state[i,]$species
  st <- spec.state[i,]$state
  results.path <- file.path("artifacts/test_results/maxent",
                        paste0(spec, "_", st, "_maxent.rds"))
  readRDS(results.path)$test.accuracy
})

DT::datatable(
  me.models,
  filter='none',
  selection='none',
  rownames=F,
  options=list(
    scrollX=T,
    scrollY=T,
    paging=F,
    searching=F,
    orderMulti=T,
    info=F,
    lengthChange = F
  )) %>%
  DT::formatStyle(columns=names(me.models), 
                  `font-size`="13px") %>%
  DT::formatSignif(4:ncol(me.models), digits=2)

```

### Load IPP Models for Comparison

```{r prior-data}

ipp.models <- purrr::map_df(1:nrow(spec.state), function(i) {
  spec <- spec.state[i,]$species
  st <- spec.state[i,]$state
  results.path <- file.path("artifacts/test_results/ipp_glm_mpl_2",
                        paste0(spec, "_", st, "_ipp_glm_mpl_2.rds"))
  readRDS(results.path)$test.accuracy
})

```

### Overall Metric Summaries

```{r box-plots-1, fig.width=4, fig.height=5}

# Reshape the data to long format
long.data <- me.models %>%
  select(common.name, Accuracy:F1) %>%
  tidyr::gather(key = "Metric", value = "Value", -common.name)

long.data.ipp <- ipp.models %>%
  select(common.name, Accuracy:F1) %>%
  tidyr::gather(key = "Metric", value = "Value", -common.name)

# Combine the old and new data frames, adding an identifier column
long.data$new.old <- "MaxEnt Models"
long.data.ipp$new.old <- "IPP Models"
combined.long <- rbind(long.data, long.data.ipp)

ggplot(combined.long, 
         aes(x = Metric, y = Value, fill = new.old)) +
    geom_boxplot(outlier.shape = NA) +
    stat_summary(aes(group = new.old), fun = mean, fill="darkred",
                 geom = "point", shape = 21, size = 2, color = "black",
                 position = position_dodge(width = 0.75),) +
    scale_fill_manual(values = c("#AAAAFF", "#FF9999"),
                      name = "Model Status",
                      labels = c("IPP Models", "MaxEnt Models")) +
    theme_minimal(base_size = 12) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          axis.text.y = element_blank(),
          axis.title = element_blank(),
          panel.background = element_rect(fill = "lightgray"),
          plot.background = element_rect(fill = "white")) + 
    coord_flip() +
    facet_wrap(~Metric, ncol=1, scales="free_y")


```

#### MaxEnt Models
```{r model-acc-me}
summary(me.models)
```


#### IPP Models (For Reference)

```{r ipp-model-acc}
summary(ipp.models)
```

### Summaries by Species

```{r box-plot-2, fig.width=8, fig.height=28}

ggplot(combined.long, 
         aes(x = Metric, y = Value, fill = new.old)) +
    geom_boxplot(outlier.shape = NA) +
    stat_summary(aes(group = new.old), fun = mean, fill="darkred",
                 geom = "point", shape = 21, size = 2, color = "black",
                 position = position_dodge(width = 0.75),) +
    scale_fill_manual(values = c("#AAAAFF", "#FF9999"),
                      name = "Model Status",
                      labels = c("IPP Models", "MaxEnt Models")) +
    theme_minimal(base_size = 12) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          axis.text.y = element_blank(),
          axis.title = element_blank(),
          panel.background = element_rect(fill = "lightgray"),
          plot.background = element_rect(fill = "white")) + 
    coord_flip() +
    facet_wrap(~common.name + Metric, ncol=2, scales="free_y")

```


### Summaries by State

```{r box-plot-3, fig.width=8, fig.height=21}

# Reshape the data to long format
long.data <- me.models %>%
  select(state, Accuracy:F1) %>%
  tidyr::gather(key = "Metric", value = "Value", -state)

long.data.ipp <- ipp.models %>%
  select(state, Accuracy:F1) %>%
  tidyr::gather(key = "Metric", value = "Value", -state)

# Combine the IPP and MaxEnt data frames, adding an identifier column
long.data$new.old <- "MaxEnt Models"
long.data.ipp$new.old <- "IPP Models"
combined.long <- rbind(long.data, long.data.ipp)

# Box plots for each state
ggplot(combined.long, 
         aes(x = Metric, y = Value, fill = new.old)) +
    geom_boxplot(outlier.shape = NA) +
    stat_summary(aes(group = new.old), fun = mean, fill="darkred",
                 geom = "point", shape = 21, size = 2, color = "black",
                 position = position_dodge(width = 0.75),) +
    scale_fill_manual(values = c("#AAAAFF", "#FF9999"),
                      name = "Model Status",
                      labels = c("IPP Models", "MaxEnt Models"))  +
    theme_minimal(base_size = 12) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          axis.text.y = element_blank(),
          axis.title = element_blank(),
          panel.background = element_rect(fill = "lightgray"),
          plot.background = element_rect(fill = "white")) + 
    coord_flip() +
    facet_wrap(~state + Metric, ncol=2, scales="free_y")

```

### Discussion


<br style="margin:0; height:0; padding:0;">

